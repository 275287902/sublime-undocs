import os
import re
# import textwrap

import bs4

from collections import namedtuple
from operator import xor

SublimeApi = namedtuple("SublimeApi", "modules")
Module = namedtuple("Module", "name functions classes")
Class = namedtuple("Class", "name constructors properties methods description")
Function = namedtuple("Function", "name signature return_type description")
Method = namedtuple("Method", "name signature return_type description")
Property = namedtuple("Property", "name value_type description")
Constructor = namedtuple("Constructor", "signature description")


def custom_dedent(string):
    """Works like textwraps.dedent but bases the indentation on the first
    indented line and not the first line.
    """
    indent = ''
    lines = string.splitlines()

    # Search for first indent
    for l in lines:
        m = re.search(r'^[ \t]+', l)
        if m:
            indent = m.group(0)
            break

    # Then strip it
    for i, l in enumerate(lines):
        if l.startswith(indent):
            lines[i] = l[len(indent):]

    return '\n'.join(lines)


def postprocess_html(text):
    """Apply some post-processing to the html string:

    - replacing html tags with .rst equivalents
    - replace closing tags that are generated by bs4
    - remove comments
    - strip whitespace
    """
    text = re.sub(r'</?tt>', '`', text)
    text = re.sub(r'<(ul|p)>', '', text)
    text = re.sub(r'</\w+>', '', text)
    text = re.sub(r'<!--.*?-->', '- ', text, flags=re.DOTALL)
    text = text.replace(r'<li>', '- ')
    text = custom_dedent(text)
    return text


def guess_type(string, just_guess=True):
    if (string.endswith("name") or string.endswith("path")
            or string in ("string", "key")):
        return "str"
    elif string == "edit":
        return "Edit"
    elif string.startswith("region"):
        return "Region"
    elif string == "view":
        return "View"
    elif string == "window":
        return "Window"
    elif string in ("point", "index", "flags", "group"):
        return "int"
    elif string.startswith("on_"):
        return "callable"
    elif string in ("String", "Int"):
        return string.lower()
    elif string == "Dictionary":
        return string.lower()
    elif string.lower() == "vector":
        return "2-tuple"
    elif just_guess:
        return ''
    else:
        return string


class FromHtmlReader(object):
    """Translates the Sublime Text from .html representation into `SublimeApi`.
    """

    def __init__(self, html):
        self.html = html

    def extract_table_rows(self, table, length):
        """Return a list of length-sized list of all rows' contents"""
        rows = []
        for tr in table.find_all('tr')[1:]:
            data = []
            for item in tr.find_all('td', limit=length):
                text = ''.join(map(str, item.contents))
                text = postprocess_html(text)
                data.append(text)

            # Make constructors/function signatures one-lined
            data[0] = ' '.join(data[0].split())

            assert len(data) == length
            rows.append(data)

        return rows

    def extract_constructors(self, table):
        assert table.attrs['class'] == ['functions']
        assert table.th.string == 'Constructors'
        rows = self.extract_table_rows(table, 2)
        return [Constructor(*row) for row in rows]

    def extract_properties(self, table):
        assert table.attrs['class'] == ['functions']
        assert table.th.string == 'Properties'
        rows = self.extract_table_rows(table, 3)
        return [Property(*row) for row in rows]

    def extract_functions(self, T, table):
        assert table.attrs['class'] == ['functions']
        assert table.th.string == 'Methods'
        rows = self.extract_table_rows(table, 3)
        funcs = []
        for func, ret_type, desc in rows:
            if func == "(no methods)":
                continue

            # Extract function name and derive signature
            m = re.match(r'^(\w+)\((.*)\)$', func)
            assert m, "Could not match: " + func
            func_name, parameters = m.groups()

            signature = []
            if parameters:
                for param in parameters.split(','):
                    optional = False
                    param = param.strip()
                    assert param

                    # <param> is optional and [string] means a list type is expected
                    is_list = False
                    if param[0] == '<':
                        assert param[-1] == '>', "%s-%s" % (func_name, param)
                        param = param[1:-1]
                        optional = True
                    elif param[0] == '[':
                        assert param[-1] == ']', "%s-%s" % (func_name, param)
                        param = param[1:-1]
                        is_list = True

                    # Do some type guessing
                    p_type = guess_type(param)
                    if is_list:
                        p_type = "list(%s)" % p_type

                    signature.append(dict(name=param, type=p_type,
                                          optional=optional))

            # Correct return type
            # [string] means a list type is expected
            is_list = False
            if ret_type[0] == '[':
                assert ret_type[-1] == ']', "%s-%s" % (func_name, ret_type)
                ret_type = ret_type[1:-1]
                is_list = True

            ret_type = guess_type(ret_type, False)
            if is_list:
                return "list(%s)" % ret_type

            # Finally append the function
            funcs.append(T(func_name, signature, ret_type, desc))

        return funcs

    def make_class(self, name):
        description = ''
        constructors = properties = methods = None

        while True:
            child = next(self.children, None)
            if not child or child.name == 'a' and 'name' in child.attrs:
                if child:
                    # Beginning of a new class or module
                    module_name, _, class_name = (child.attrs['name']
                                                  .partition('.'))
                else:
                    # End of document
                    module_name = class_name = None
                return (Class(name, constructors, properties, methods,
                              description),
                        module_name,
                        class_name)

            elif child.name == 'table':
                table_type = child.th.text
                if table_type == 'Constructors':
                    constructors = self.extract_constructors(child)
                    print("Found", len(constructors), "constructors for module",
                          name)
                elif table_type == 'Properties':
                    properties = self.extract_properties(child)
                    print("Found", len(properties), "properties for module",
                          name)
                elif table_type == 'Methods':
                    methods = self.extract_functions(Method, child)
                    print("Found", len(methods), "methods for module", name)
                else:
                    assert False, "Unrecognized table type " + table_type

            elif child.name == 'p' and '<table' in str(child):
                # Another unclosed <p> tag, in the Edit class,
                # so, fix the children iterator (again)
                self.children = iter(child.children)
            else:
                # We didn't do anything with the element, so we just add it to
                # the description
                description += str(child)

    def make_module(self, name):
        # Collect these values
        description = ''
        functions = None
        classes = []
        # Indicator of next class name
        class_name = None

        child = None
        while True:
            if class_name:
                st_cls, module_name, class_name = self.make_class(class_name)
                classes.append(st_cls)
                print("created class", st_cls.name)
                assert xor(module_name == name, not class_name)
                if not class_name:
                    print("Found", len(classes), "classes for module", name)
                    return Module(name, functions, classes), module_name
                continue

            child = next(self.children, None)
            if not child:
                print("Found", len(classes), "classes for module", name)
                return Module(name, functions, classes), None

            if child.name == 'table':
                # We found a table
                assert not functions, "found two tables for module " + name
                functions = self.extract_functions(Function, child)
                print("Found", len(functions), "functions for module", name)
                continue

            elif child.name == 'a' and 'name' in child.attrs:
                # Beginning of a new class
                module_name, _, class_name = (child.attrs['name']
                                              .partition('.'))
                assert module_name == name
                continue

            else:
                # We didn't do anything with the element, so we just add it to
                # the description
                description += str(child)

    def to_api(self):
        # Collect these values
        modules = []
        # Indicator of next module name
        module_name = None

        self.children = iter(self.html.body.children)

        while True:
            if module_name:
                # Construct the module
                module, module_name = self.make_module(module_name)
                modules.append(module)
                print("created module", module.name)
                continue

            child = next(self.children, None)
            if not child:
                # Reached the end
                return SublimeApi(modules)

            if child.name == 'p' and '<a name="sublime"></a>' in str(child):
                # Sadly, the HTML of the API docs is invalid and everything
                # after the first <a> tag gets placed inside of an unclosed <p>
                # tag. Thus, we adjust our children iterator.
                self.children = iter(child.children)

            elif child.name == 'a' and 'name' in child.attrs:
                # Each module/class is associated with an 'a' tag,
                # so search for it
                module_name = child.attrs['name']
                assert '.' not in module_name

    @staticmethod
    def from_path(path):
        with open(path, 'rt') as f:
            return FromHtmlReader(bs4.BeautifulSoup(f.read()))


def read(path):
    """Parse API .html representation.

    @path
        Path to the .html representation of the Sublime Text API.
    """
    return FromHtmlReader.from_path(path)


if __name__ == '__main__':
    if os.path.exists('api.html'):
        api = read('api.html').to_api()
        print(api)
    else:
        here = os.path.abspath(os.path.dirname(__file__))
        print('no api.html file found in {}'.format(here))
